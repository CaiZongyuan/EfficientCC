{
  "total_files": 25,
  "analyzed_files": [
    {
      "file": "task_agent.py",
      "summary": "Documentation for ReActAgent in AgentScope, demonstrating real-time steering, parallel tool calls, and structured output features with implementation examples.",
      "toc": ["ReAct Agent", "Realtime Steering", "Parallel Tool Calls", "Structured Output", "Customizing Agent", "Further Reading"],
      "key_apis": ["ReActAgent", "AgentBase", "ReActAgentBase", "UserAgent", "ToolResponse", "TextBlock", "Msg", "DashScopeChatModel", "DashScopeChatFormatter", "InMemoryMemory", "Toolkit", "asyncio.gather", "BaseModel"],
      "code_examples": ["Async tool function with await asyncio.sleep()", "Tool registration with toolkit.register_tool_function()", "Parallel tool calls with parallel_tool_calls=True", "Structured output with pydantic BaseModel", "Interruption handling with asyncio.CancelledError", "Agent initialization with model, memory, formatter, and toolkit"],
      "prerequisites": ["agentscope Python package", "pydantic library", "asyncio module", "DashScope API key and access", "Environment variables (DASHSCOPE_API_KEY)", "Understanding of async/await patterns"]
    },
    {
      "file": "task_memory.py",
      "summary": "Documentation file describing AgentScope's memory system, which stores agent context and provides retrieval capabilities through a base MemoryBase class and InMemoryMemory implementation.",
      "toc": ["Memory Overview", "Customize Memory", "Further Reading"],
      "key_apis": ["MemoryBase", "InMemoryMemory", "Msg", "add", "delete", "size", "clear", "get_memory", "state_dict", "load_state_dict"],
      "code_examples": ["Memory inheritance pattern for customization", "State dictionary serialization/deserialization"],
      "prerequisites": ["agentscope.memory module", "Msg objects for message storage"]
    },
    {
      "file": "task_state.py",
      "summary": "Documentation and examples for AgentScope's state and session management system, including StateModule class for automatic state registration, nested serialization, and JSONSession for persistent session storage.",
      "toc": ["State Module", "Session Management", "Saving Session State", "Loading Session State"],
      "key_apis": ["StateModule", "register_state", "state_dict", "load_state_dict", "JSONSession", "save_session_state", "load_session_state", "ReActAgent", "InMemoryMemory", "DashScopeChatModel", "Toolkit"],
      "code_examples": ["Custom StateModule classes with manual registration", "Nested state serialization with StateModule inheritance", "Agent state persistence with state_dict() and load_state_dict()", "Session-based state saving with JSONSession.save_session_state()", "Session state restoration with JSONSession.load_session_state()"],
      "prerequisites": ["agentscope.agent.ReActAgent", "agentscope.formatter.DashScopeChatFormatter", "agentscope.memory.InMemoryMemory", "agentscope.message.Msg", "agentscope.model.DashScopeChatModel", "agentscope.module.StateModule", "agentscope.session.JSONSession", "agentscope.tool.Toolkit", "asyncio", "json", "os"]
    },
    {
      "file": "task_model.py",
      "summary": "AgentScope model API tutorial covering multiple model providers (OpenAI, DashScope, Anthropic, Gemini, Ollama), streaming responses, reasoning capabilities, and tool calling integration.",
      "toc": ["Model Overview", "Supported Providers", "Common Methods", "Streaming", "Reasoning", "Tools API", "Further Reading"],
      "key_apis": ["OpenAIChatModel", "DashScopeChatModel", "AnthropicChatModel", "GeminiChatModel", "OllamaChatModel", "ChatResponse", "ThinkingBlock", "ToolUseBlock", "TextBlock", "Msg"],
      "code_examples": ["async model calls with messages", "streaming response handling with async generators", "reasoning models with ThinkingBlock", "tool calling with JSON schemas", "response content extraction and Msg creation"],
      "prerequisites": ["agentscope.message module", "agentscope.model module", "asyncio for async operations", "environment variables for API keys (DASHSCOPE_API_KEY)"]
    },
    {
      "file": "task_long_term_memory.py",
      "summary": "A comprehensive guide to implementing long-term memory systems in AgentScope, covering mem0 and ReMe implementations with integration patterns for ReAct agents.",
      "toc": ["Long-Term Memory Overview", "Using mem0 Long-Term Memory", "Basic usage example", "Integration with ReAct Agent", "Using ReMe Long-Term Memory", "Customizing Long-Term Memory", "Further Reading"],
      "key_apis": ["Mem0LongTermMemory", "ReMePersonalLongTermMemory", "LongTermMemoryBase", "ReActAgent", "record", "retrieve", "record_to_memory", "retrieve_from_memory", "DashScopeChatModel", "DashScopeTextEmbedding", "InMemoryMemory", "Msg"],
      "code_examples": ["Basic async/await memory operations", "Agent-controlled vs static-controlled memory modes", "Context manager usage with ReMe", "System prompt integration for memory management", "Message-based recording and retrieval"],
      "prerequisites": ["agentscope", "mem0", "dashscope", "asyncio", "Environment variables: DASHSCOPE_API_KEY"]
    },
    {
      "file": "task_plan.py",
      "summary": "The Plan Module documentation demonstrates how agents can break down complex tasks into manageable sub-tasks and execute them systematically using PlanNotebook class integration with ReActAgent.",
      "toc": ["PlanNotebook", "Working with ReActAgent", "Manual Plan Specification", "Agent-Managed Plan Execution", "Plan Visualization and Monitoring"],
      "key_apis": ["PlanNotebook", "Plan", "SubTask", "ReActAgent", "DashScopeChatModel", "DashScopeChatFormatter", "DefaultPlanToHint", "PlanStorageBase"],
      "code_examples": ["PlanNotebook instantiation with parameters", "Async function patterns for plan management", "Manual plan creation with SubTask objects", "ReActAgent initialization with plan_notebook parameter", "Plan change hook function template"],
      "prerequisites": ["agentscope.agent.ReActAgent", "agentscope.formatter.DashScopeChatFormatter", "agentscope.model.DashScopeChatModel", "agentscope.plan module classes", "asyncio for asynchronous operations", "os module for environment variables"]
    },
    {
      "file": "task_tool.py",
      "summary": "AgentScope Toolkit documentation covering tool function management, execution, interruption handling, and automatic tool organization with groups.",
      "toc": ["Tool Function", "Toolkit", "Basic Usage", "Extending JSON Schema Dynamically", "Interrupting Tool Execution", "Automatic Tool Management"],
      "key_apis": ["ToolResponse", "Toolkit", "register_tool_function", "call_tool_function", "get_json_schemas", "set_extended_model", "reset_equipped_tools", "create_tool_group", "update_tool_groups", "get_activated_notes", "execute_python_code", "TextBlock", "ToolUseBlock"],
      "code_examples": ["Tool function template with docstring and type hints", "Async tool function with ToolResponse return", "Preset arguments for API keys", "JSON Schema extension with Pydantic models", "Async generator streaming functions", "Tool interruption with asyncio.CancelledError", "Tool group creation and management", "Meta tool function for dynamic tool activation"],
      "prerequisites": ["agentscope package", "pydantic for data models", "asyncio for async functions", "Python type hints support", "JSON Schema knowledge"]
    },
    {
      "file": "task_pipeline.py",
      "summary": "AgentScope pipeline module documentation demonstrating multi-agent orchestration patterns including message broadcasting with MsgHub, sequential and fanout pipelines, and streaming message handling.",
      "toc": ["Broadcasting with MsgHub", "Dynamic Participant Management", "Pipeline implementations", "Sequential Pipeline", "Fanout Pipeline", "Stream Printing Messages", "Advanced Pipeline Features"],
      "key_apis": ["MsgHub", "sequential_pipeline", "SequentialPipeline", "fanout_pipeline", "FanoutPipeline", "stream_printing_messages", "ReActAgent", "DashScopeChatModel", "DashScopeMultiAgentFormatter"],
      "code_examples": ["Async context manager pattern for MsgHub broadcasting", "Agent creation factory function with model configuration", "Sequential agent chaining with message passing", "Concurrent fanout execution with optional gather control", "Streaming message processing with async generators", "Class-based pipeline reuse patterns"],
      "prerequisites": ["agentscope Python package", "DashScope API key environment variable", "AsyncIO programming concepts", "ReActAgent framework knowledge", "Python async context managers"]
    },
    {
      "file": "quickstart_agent.py",
      "summary": "A comprehensive tutorial file demonstrating how to create and use ReAct agents in AgentScope, covering both built-in ReActAgent usage and custom agent creation from scratch with memory management and tool integration.",
      "toc": ["Creating ReAct Agent", "Creating From Scratch", "Further Reading"],
      "key_apis": ["ReActAgent", "AgentBase", "DashScopeChatModel", "DashScopeChatFormatter", "InMemoryMemory", "Toolkit", "execute_python_code", "Msg"],
      "code_examples": ["Async agent initialization and configuration", "Tool registration and management", "Memory-based conversation handling", "Custom agent class inheritance", "Message formatting and model interaction", "Interrupt handling patterns"],
      "prerequisites": ["agentscope.agents", "agentscope.formatter", "agentscope.memory", "agentscope.message", "agentscope.model", "agentscope.tool", "asyncio", "os", "DASHSCOPE_API_KEY environment variable"]
    },
    {
      "file": "quickstart_key_concept.py",
      "summary": "AgentScope key concepts documentation explaining fundamental building blocks including State, Message, Tool, Agent, Formatter, and Long-Term Memory from an engineering perspective.",
      "toc": ["State", "Message", "Tool", "Agent", "Formatter", "Long-Term Memory"],
      "key_apis": ["load_state_dict", "state_dict", "AgentBase", "reply", "observe", "print", "handle_interrupt", "ReActAgentBase", "_reasoning", "_acting"],
      "code_examples": ["Multi-agent formatter tool function pattern", "Async tool function calling another agent", "Nested state management for stateful objects"],
      "prerequisites": ["Understanding of LLM APIs and message formats", "Basic knowledge of agent orchestration concepts", "Familiarity with Python async/await patterns"]
    },
    {
      "file": "quickstart_message.py",
      "summary": "Comprehensive tutorial on creating and managing Message objects in AgentScope, supporting multimodal content including text, images, audio, video, thinking blocks, and tool interactions.",
      "toc": ["Creating Textual Message", "Creating Multimodal Message", "Creating Thinking Message", "Creating Tool Use/Result Message", "Serialization and Deserialization", "Property Functions"],
      "key_apis": ["Msg", "Base64Source", "TextBlock", "ThinkingBlock", "ImageBlock", "AudioBlock", "VideoBlock", "ToolUseBlock", "ToolResultBlock", "to_dict", "from_dict", "get_text_content", "get_content_blocks", "has_content_blocks"],
      "code_examples": ["Msg(name='Jarvis', role='assistant', content='Hi! How can I help you?')", "TextBlock(type='text', text='Hello, world!')", "ImageBlock(type='image', source=Base64Source(...))", "ToolUseBlock(type='tool_use', id='343', name='get_weather', input={'location': 'Beijing'})", "serialized_msg = msg.to_dict()", "new_msg = Msg.from_dict(serialized_msg)"],
      "prerequisites": ["agentscope.message module", "json module", "Base64 encoding for multimedia content"]
    },
    {
      "file": "task_embedding.py",
      "summary": "Documentation and examples for AgentScope's embedding module, providing unified interface for vector representation generation with caching support and multiple provider integrations.",
      "toc": ["Embedding module overview", "Multiple embedding providers (OpenAI, Gemini, DashScope, Ollama)", "EmbeddingCacheBase and FileEmbeddingCache", "Performance optimization with caching"],
      "key_apis": ["OpenAITextEmbedding", "GeminiTextEmbedding", "DashScopeTextEmbedding", "DashScopeMultiModalEmbedding", "OllamaTextEmbedding", "EmbeddingModelBase", "FileEmbeddingCache", "EmbeddingCacheBase"],
      "code_examples": ["DashScope text embedding initialization with model_name and api_key", "Async embedding calls: await embedding_model(texts)", "EmbeddingResponse object with id, created_at, usage, embeddings fields", "FileEmbeddingCache configuration with cache_dir, max_file_number, max_cache_size", "Performance comparison between API calls and cache hits"],
      "prerequisites": ["agentscope.embedding module", "asyncio for asynchronous operations", "os.getenv for API key retrieval", "tempfile for temporary cache directories", "Environment variables: DASHSCOPE_API_KEY"]
    },
    {
      "file": "task_token.py",
      "summary": "AgentScope token counter module documentation that provides token counting functionality for different AI providers to estimate prompt tokens before API calls.",
      "toc": ["Token overview and providers", "Token counter classes and capabilities", "OpenAI token counting example", "Further reading references"],
      "key_apis": ["OpenAITokenCounter", "AnthropicTokenCounter", "GeminiTokenCounter", "HuggingFaceTokenCounter"],
      "code_examples": ["async token counting with OpenAITokenCounter", "count() method for token calculation", "model-specific token counter initialization"],
      "prerequisites": ["agentscope.token module", "asyncio for asynchronous operations", "Provider-specific models (gpt-4.1 for OpenAI example)"]
    },
    {
      "file": "task_tracing.py",
      "summary": "AgentScope implements OpenTelemetry-based tracing for monitoring and debugging agent applications with built-in support for LLM, tool, agent, and formatter tracing, error tracking, and visualization in AgentScope Studio.",
      "toc": ["Setting Up", "AgentScope Studio", "Third-party Platforms", "Customizing Tracing", "Tracing LLMs", "Tracing Agent", "Tracing Formatter", "General Tracing"],
      "key_apis": ["agentscope.init", "@trace_llm", "@trace_reply", "@trace_format", "@trace"],
      "code_examples": ["Environment variable configuration for third-party platforms", "Decorator-based tracing for different module types", "Base64 authentication setup for LangFuse", "OpenTelemetry-compatible backend connection"],
      "prerequisites": ["OpenTelemetry SDK", "PHOENIX_API_KEY environment variable (for Arize-Phoenix)", "LANGFUSE_PUBLIC_KEY and LANGFUSE_SECRET_KEY (for LangFuse)", "AgentScope Studio URL or third-party tracing endpoint"]
    },
    {
      "file": "task_studio.py",
      "summary": "Documentation for AgentScope Studio, a local-deployed web application that provides project management, visualization, and a built-in 'Friday' agent for developing agent applications.",
      "toc": ["Quick Start", "Friday Agent"],
      "key_apis": ["agentscope.init", "as_studio"],
      "code_examples": ["npm install -g @agentscope/studio", "as_studio", "agentscope.init(studio_url=\"http://localhost:8000\")"],
      "prerequisites": ["npm (Node Package Manager)", "agentscope Python package"]
    },
    {
      "file": "task_eval.py",
      "summary": "AgentScope evaluation framework documentation showing how to build and use benchmarks, metrics, tasks, and evaluators for assessing agent performance with examples.",
      "toc": ["Evaluation Overview", "Core Components", "Tasks, Solutions and Metrics to Benchmark", "Evaluators"],
      "key_apis": ["SolutionOutput", "MetricBase", "MetricResult", "MetricType", "Task", "BenchmarkBase", "GeneralEvaluator", "RayEvaluator", "FileEvaluatorStorage", "ReActAgent"],
      "code_examples": ["Custom metric class inheriting MetricBase with async __call__ method", "Benchmark class with iterator methods (__iter__, __getitem__, __len__)", "Async solution generation function with ReActAgent and structured output", "GeneralEvaluator setup with storage and worker configuration"],
      "prerequisites": ["Ray framework for parallel evaluation", "DashScope API key for model access", "agentscope package dependencies", "asyncio for async evaluation execution"]
    },
    {
      "file": "task_hook.py",
      "summary": "AgentScope hook system documentation showing how to customize agent behaviors through pre- and post-hooks that wrap core functions like reply, print, observe, reasoning, and acting.",
      "toc": ["Hook Signature", "Hook Management"],
      "key_apis": ["register_instance_hook", "remove_instance_hook", "clear_instance_hooks", "register_class_hook", "remove_class_hook", "clear_class_hooks"],
      "code_examples": ["Pre-hook template with modified kwargs return", "Post-hook template with output modification", "Instance-level vs class-level hook registration", "Hook chaining and return value handling"],
      "prerequisites": ["agentscope.agent.ReActAgentBase", "agentscope.agent.AgentBase", "agentscope.message.Msg"]
    },
    {
      "file": "task_rag.py",
      "summary": "Comprehensive tutorial demonstrating Retrieval-Augmented Generation (RAG) capabilities in AgentScope, including text and multimodal RAG, custom component development, and integration with ReActAgent in both agentic and generic manners.",
      "toc": ["Using RAG Module", "Customizing RAG Components", "Integrating with ReActAgent", "Agentic Manner", "Generic Manner", "Multimodal RAG"],
      "key_apis": ["TextReader", "ImageReader", "SimpleKnowledge", "QdrantStore", "Document", "DashScopeTextEmbedding", "DashScopeMultiModalEmbedding", "ReActAgent", "Msg", "Toolkit"],
      "code_examples": ["Async document reading with chunking: TextReader(chunk_size=512, split_by='paragraph')", "Knowledge base creation with embedding model and vector store", "Tool registration for agentic RAG: toolkit.register_tool_function()", "Generic RAG integration by setting knowledge parameter in ReActAgent", "Multimodal RAG using ImageReader and DashScopeMultiModalEmbedding"],
      "prerequisites": ["agentscope", "matplotlib", "qdrant-client (for vector storage)", "dashscope API key for embedding models", "Environment variables: DASHSCOPE_API_KEY"]
    },
    {
      "file": "task_mcp.py",
      "summary": "Documentation and tutorial for AgentScope's MCP (Model Context Protocol) support, covering HTTP and StdIO servers with stateful and stateless clients for tool function management.",
      "toc": ["MCP Client", "MCP as Tool", "Server-Level Management", "Function-Level Management", "Further Reading"],
      "key_apis": ["HttpStatefulClient", "HttpStatelessClient", "Toolkit", "list_tools", "get_callable_function", "register_mcp_client", "remove_tool_function", "remove_mcp_clients"],
      "code_examples": ["Async function registration with toolkit.register_mcp_client()", "Stateless vs stateful client initialization patterns", "Function-level tool retrieval and direct invocation", "Tool removal with remove_tool_function() and remove_mcp_clients()"],
      "prerequisites": ["agentscope.mcp module", "agentscope.tool.Toolkit", "asyncio for async operations", "GAODE_API_KEY environment variable"]
    },
    {
      "file": "task_prompt.py",
      "summary": "Comprehensive documentation on AgentScope's prompt formatter module, covering message conversion for different LLM APIs, token truncation, and multi-agent conversation handling.",
      "toc": ["Prompt Formatter Overview", "Built-in Formatters by Provider", "Message Block Support", "ReAct-Oriented Formatting", "Multi-Agent Message Examples", "Truncation-based Formatting", "Token Counting", "Customizing Formatter Classes", "Base Class Inheritance"],
      "key_apis": ["DashScopeMultiAgentFormatter", "OpenAIChatFormatter", "AnthropicChatFormatter", "GeminiChatFormatter", "OllamaChatFormatter", "DeepSeekChatFormatter", "HuggingFaceTokenCounter", "FormatterBase", "TruncatedFormatterBase"],
      "code_examples": ["Multi-agent message formatting with ToolUseBlock and ToolResultBlock", "Async formatter usage with asyncio.run()", "Token counting implementation", "Truncated formatter with max_tokens limit", "Custom formatter inheritance patterns"],
      "prerequisites": ["agentscope.formatter module", "agentscope.token module", "agentscope.message module", "asyncio for asynchronous operations", "HuggingFace models for token counting", "Understanding of LLM API formats"]
    },
    {
      "file": "workflow_concurrent_agents.py",
      "summary": "Demonstrates concurrent execution of agents using asyncio.gather for parallel processing of agent tasks.",
      "toc": ["Concurrent Agents Overview", "ExampleAgent Class Definition", "Asynchronous Reply Method", "Concurrent Execution Function", "Main Execution Block"],
      "key_apis": ["asyncio.gather", "asyncio.run", "asyncio.sleep", "AgentBase", "datetime.now"],
      "code_examples": ["async def reply(self, *args: Any, **kwargs: Any) -> None", "await asyncio.gather(agent1(), agent2())", "class ExampleAgent(AgentBase)"],
      "prerequisites": ["asyncio module", "datetime module", "agentscope.agent.AgentBase class", "Python 3.7+ for async/await support"]
    },
    {
      "file": "workflow_conversation.py",
      "summary": "A tutorial demonstrating conversation patterns in AgentScope framework, covering both user-agent chatbot interactions and multi-agent conversations with message sharing capabilities.",
      "toc": ["User-Agent Conversation", "More than Two Agents", "Prompt Construction", "Message Sharing", "Further Reading"],
      "key_apis": ["ReActAgent", "UserAgent", "InMemoryMemory", "DashScopeChatFormatter", "DashScopeMultiAgentFormatter", "DashScopeChatModel", "Msg", "MsgHub", "Toolkit"],
      "code_examples": ["User-agent conversation with message exchange loop", "Multi-agent prompt formatting with DashScopeMultiAgentFormatter", "MsgHub context manager for automatic message broadcasting", "Memory retrieval and inspection patterns"],
      "prerequisites": ["agentscope Python package", "DASHSCOPE_API_KEY environment variable", "asyncio support for async agent operations"]
    },
    {
      "file": "workflow_handoffs.py",
      "summary": "This documentation demonstrates how to implement Orchestrator-Workers workflow pattern using AgentScope with tool calls, where an orchestrator agent dynamically creates worker agents to complete tasks.",
      "toc": ["Handoffs Workflow Overview", "Worker Creation Tool Function", "Orchestrator Implementation", "Task Execution Example"],
      "key_apis": ["ReActAgent", "DashScopeChatModel", "DashScopeChatFormatter", "InMemoryMemory", "Toolkit", "ToolResponse", "execute_python_code", "create_worker", "run_handoffs"],
      "code_examples": ["async worker creation with tool functions", "dynamic agent initialization with toolkit registration", "orchestrator-worker communication pattern using Msg objects"],
      "prerequisites": ["agentscope package", "DASHSCOPE_API_KEY environment variable", "qwen-max model access", "asyncio for asynchronous execution"]
    },
    {
      "file": "workflow_routing.py",
      "summary": "This document demonstrates two methods for implementing agent routing in AgentScope: structured output routing and tool-based routing for directing user queries to appropriate downstream agents.",
      "toc": ["Routing by Structured Output", "Routing by Tool Calls"],
      "key_apis": ["ReActAgent", "RoutingChoice", "DashScopeChatModel", "DashScopeChatFormatter", "InMemoryMemory", "Toolkit", "ToolResponse", "Msg"],
      "code_examples": ["Structured output routing with BaseModel and Literal types", "Tool-based routing with Toolkit.register_tool_function", "Async agent initialization with ReActAgent", "Message handling with Msg class", "ToolResponse wrapping for downstream agent results"],
      "prerequisites": ["agentscope package", "pydantic", "DASHSCOPE_API_KEY environment variable", "asyncio for async execution"]
    },
    {
      "file": "workflow_multiagent_debate.py",
      "summary": "Implementation of a multi-agent debate workflow where two debater agents discuss a topic while a moderator evaluates their answers and determines when a correct solution is reached.",
      "toc": ["Multi-Agent Debate Introduction", "Agent Creation Functions", "Structured Output Model", "Debate Execution Workflow", "Further Reading"],
      "key_apis": ["ReActAgent", "DashScopeChatModel", "DashScopeMultiAgentFormatter", "MsgHub", "Msg", "BaseModel", "Field"],
      "code_examples": ["create_solver_agent() function for creating debater agents", "MsgHub context manager for multi-agent communication", "Structured output with JudgeModel class", "Async debate loop with conditional termination"],
      "prerequisites": ["agentscope library", "pydantic", "asyncio", "DASHSCOPE_API_KEY environment variable", "qwen-max model access"]
    }
  ],
  "summary_stats": {
    "total_key_apis": 150,
    "main_categories": {
      "Core Components": 8,
      "Agent Framework": 5,
      "Memory & State": 3,
      "Model Integration": 1,
      "Tool Management": 1,
      "Workflow Patterns": 5,
      "Development Tools": 2
    }
  },
  "coverage_analysis": {
    "agent_creation": ["task_agent.py", "quickstart_agent.py", "quickstart_key_concept.py"],
    "memory_management": ["task_memory.py", "task_state.py", "task_long_term_memory.py"],
    "model_integration": ["task_model.py", "task_embedding.py", "task_token.py"],
    "tool_system": ["task_tool.py", "task_mcp.py"],
    "workflow_patterns": ["workflow_concurrent_agents.py", "workflow_conversation.py", "workflow_handoffs.py", "workflow_routing.py", "workflow_multiagent_debate.py"],
    "development_tools": ["task_studio.py", "task_tracing.py", "task_eval.py", "task_hook.py"],
    "advanced_features": ["task_plan.py", "task_pipeline.py", "task_rag.py", "task_prompt.py"],
    "getting_started": ["quickstart_agent.py", "quickstart_key_concept.py", "quickstart_message.py"]
  }
}